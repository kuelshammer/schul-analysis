# Schul-Analysis Framework

Ein Python Framework f√ºr Schul-Analysis mit exakter Berechnung und Marimo-Integration, entwickelt f√ºr Mathematiklehrer und Sch√ºler.

## Features

- **Exakte mathematische Berechnungen** mit SymPy (keine numerischen Approximationen)
- **Flexible Konstruktoren**: String (`"x^3-2x+1"`), Liste (`[1, 0, -2, 1]`) oder Dictionary
- **Detaillierte L√∂sungswege** als Markdown mit LaTeX-Unterst√ºtzung
- **Marimo-Integration** f√ºr interaktive Notebooks
- **P√§dagogische Darstellung** mit deutschen Methodennamen
- **üî• Mathematisch korrekte Visualisierung** mit Plotly (keine verzerrten Parabeln!)
- **üéØ Intuitive `__call__`-Syntax**: `f(2)` statt `f.wert(2)` f√ºr nat√ºrliche mathematische Notation
- **üÜï Lineare Gleichungssysteme (LGS)** mit intuitiver Syntax `LGS(f(3)==4, f(2)==0, f1(0)=0)`

## üîß Neue Features in Version 1.2

### üÜï Lineare Gleichungssysteme (LGS) f√ºr parametrische Funktionen

Das Framework unterst√ºtzt jetzt das L√∂sen von linearen Gleichungssystemen f√ºr parametrische Funktionen mit intuitiver Syntax:

```python
# Erstelle Parameter und Variable
a, b, c = Parameter("a"), Parameter("b"), Parameter("c")
x = Variable("x")

# Erstelle parametrische Funktion f(x) = ax¬≤ + bx + c
f = ParametrischeFunktion([a, b, c], [x])

# Finde Parabel durch 3 Punkte mit intuitiver Syntax
gl1 = f(1) == 2  # f(1) = 2
gl2 = f(2) == 3  # f(2) = 3
gl3 = f(3) == 6  # f(3) = 6

# Erstelle und l√∂se LGS
lgs = LGS(gl1, gl2, gl3)
loesung = lgs.l√∂se()

# Ergebnis: {a: 3.0, b: -2.0, c: 1.0}
# Gefundene Parabel: f(x) = x¬≤ - 2x + 3
```

#### Funktion mit Ableitungsbedingungen

```python
# Erste Ableitung
f1 = Ableitung(f)  # f'(x) = 2ax + b

# Bedingungen mit Ableitungen
gl1 = f(0) == 1   # f(0) = 1
gl2 = f(1) == 3   # f(1) = 3
gl3 = f1(1) == 4  # f'(1) = 4

lgs = LGS(gl1, gl2, gl3)
loesung = lgs.l√∂se()

# Ergebnis: {a: 2.0, b: 0.0, c: 1.0}
# Funktion: f(x) = 2x¬≤ + 1
```

#### P√§dagogische Features

- **Intuitive Gleichungssyntax**: `f(3) == 4` entspricht der mathematischen Notation
- **Automatische Koeffizientenextraktion**: Aus ax¬≤ + bx + c wird das LGS-System
- **Detaillierte Inspektion**: `zeige_gleichungen()`, `zeige_matrix()`, `zeige_unbekannte()`
- **P√§dagogische Fehlermeldungen**: Verst√§ndliche Erkl√§rungen bei widerspr√ºchlichen Bedingungen

## üîß Neue Features in Version 1.1

### üéØ Intuitive `__call__`-Syntax f√ºr Funktionen

Das Framework unterst√ºtzt jetzt die nat√ºrliche mathematische Notation `f(x)`:

```python
# Ganzrationale Funktionen
f = GanzrationaleFunktion("x^2 + 2x - 3")
print(f(2))     # 5.0 (statt f.wert(2))

# Parametrische Funktionen
x = Variable("x")
a = Parameter("a")
f_param = ParametrischeFunktion([a, 1, 0], [x])  # a*x¬≤ + x
print(f_param(2))    # 4a + 2 (symbolisches Ergebnis)

# Mit konkreten Werten
f_konkret = f_param.mit_wert(a=3)
print(f_konkret(2))  # 14.0
```

### üî• Neue Prime-Notation f√ºr Ableitungen

Das Framework unterst√ºtzt jetzt die intuitive mathematische Notation f√ºr Ableitungen:

```python
# Mathematisch: f'(x) = 2x + 3, f'(2) = 7
f = GanzrationaleFunktion("x^2 + 3x - 2")
f_strich = Ableitung(f)        # f'(x) = 2x + 3
print(f_strich(2))            # 7.0

# H√∂here Ableitungen
f_zwei_strich = Ableitung(f_strich)  # f''(x) = 2
print(f_zwei_strich(5))       # 2.0

# Funktioniert auch mit parametrischen Funktionen
t = Variable("t")
g = ParametrischeFunktion("t^2 + 2*t", t)
g_strich = Ableitung(g)        # g'(t) = 2t + 2
print(g_strich(3))            # 8.0

# Kombination mit __call__ Syntax
f = GanzrationaleFunktion("x^3 - 2x^2 + 5x - 1")
f_strich = Ableitung(f)       # f'(x) = 3x¬≤ - 4x + 5
print(f_strich(1))            # 4.0

f_zwei_strich = Ableitung(f_strich)  # f''(x) = 6x - 4
print(f_zwei_strich(1))       # 2.0

f_drei_strich = Ableitung(f_zwei_strich)  # f'''(x) = 6
print(f_drei_strich(1))       # 6.0
```

**Vorteile:**

- **Extrem intuitive Notation**: `f_strich = Ableitung(f)` entspricht mathematisch `f' = df/dx`
- **Konsistente Syntax**: Funktioniert f√ºr alle Funktionstypen gleich
- **Nat√ºrliche Aufrufe**: `f_strich(2)` entspricht `f'(2)`
- **Kombinierbar**: H√∂here Ableitungen durch Kaskadierung m√∂glich
- **Abw√§rtskompatibel**: Bestehende `f.ableitung()` Methode bleibt erhalten

### üìã Gleichungssyntax (Vorbereitung f√ºr LGS)

Die Syntax `f(x) == wert` wird vorbereitet:

```python
# Wird in Zukunft Lineare Gleichungen f√ºr LGS erstellen
bedingung = f(3) == 7  # f(3) = 7
```

## üî• Visualisierungs-Strategie

### Plotly (üèÜ Hauptpaket f√ºr Mathematik)

**Vorteile:**

- ‚úÖ **Perfekte mathematische Korrektheit** durch Aspect Ratio Control
- ‚úÖ **Keine verzerrten Parabeln** - `scaleanchor="y", scaleratio=1`
- ‚úÖ **Interaktive Funktionen**: Zoom, pan, 3D-Rotation
- ‚úÖ **Schul-Konventionen**: Achsen im Ursprung, Gitterlinien
- ‚úÖ **Marimo-Integration**: `mo.ui.plotly()`

**Anwendungsbereiche:**

- üî• Funktionsgraphen (Parabeln, Polynome)
- üî• Nullstellen-Visualisierung
- üî• Extremstellen-Darstellung
- üî• Ableitungsvergleiche
- üî• Geometrische Konstruktionen

### Altair (üìä Sekund√§rpaket f√ºr Statistik)

**Vorteile:**

- ‚úÖ **Data Selection** - interaktive Datenfilterung
- ‚úÖ **Statistische Diagramme**: Balken, Boxplots, Streudiagramme
- ‚úÖ **Datenanalyse**: Aggregation, Gruppierung
- ‚úÖ **Marimo-Integration**: `mo.ui.altair_chart()`

**Einschr√§nkungen:**

- ‚ùå **Kein Aspect Ratio Control** - Parabeln werden verzerrt
- ‚ùå **Nicht f√ºr mathematische Korrektheit geeignet**

### Matplotlib (üñºÔ∏è Statische Exporte)

**Vorteile:**

- ‚úÖ **PDF/PNG Export** f√ºr Druckmaterialien
- ‚úÖ **Vollst√§ndige Kontrolle** √ºber Layout
- ‚úÖ **Wissenschaftliche Publikationen**

**Einschr√§nkungen:**

- ‚ùå **Nicht reaktiv** - keine Interaktivit√§t
- ‚ùå **Keine Aspect Ratio Kontrolle**

### Wann welches Paket?

| Anwendung                  | Plotly     | Altair     | Matplotlib       |
| -------------------------- | ---------- | ---------- | ---------------- |
| **Funktionsgraphen**       | üî• **Ja**  | ‚ùå Nein    | ‚ö†Ô∏è Eingeschr√§nkt |
| **Parabel-Darstellung**    | üî• **Ja**  | ‚ùå Nein    | ‚ùå Nein          |
| **Statistische Diagramme** | ‚ö†Ô∏è M√∂glich | üî• **Ja**  | ‚ö†Ô∏è M√∂glich       |
| **Interaktive Analyse**    | üî• **Ja**  | üî• **Ja**  | ‚ùå Nein          |
| **Druck-Export**           | ‚ö†Ô∏è M√∂glich | ‚ö†Ô∏è M√∂glich | üî• **Ja**        |

## Installation

### Basisinstallation (f√ºr Benutzer)

```bash
# Klonen des Repositories
git clone https://github.com/kuelshammer/schul-analysis.git
cd schul-analysis

# Installation mit uv
uv sync
```

### F√ºr Entwickler

```bash
# Alle Entwicklungstools installieren
uv sync --all-groups

# Oder gruppenweise:
uv sync --group dev      # Entwicklungstools (ruff, ty, pytest)
uv sync --group docs     # Dokumentationstools (sphinx)
uv sync --group viz-math # Mathematische Visualisierung (Plotly) üî• EMPFOHLEN
uv sync --group viz-stats # Statistische Visualisierung (Altair)
uv sync --group viz-static # Statische Exporte (Matplotlib)
uv sync --group types    # Type stubs
```

### Nur Core Dependencies

```bash
# Nur die f√ºr den Betrieb notwendigen Pakete
uv sync --no-dev
```

## Paketstruktur

### Core Dependencies (werden immer installiert)

- `sympy>=1.14.0` - Symbolische Mathematik
- `marimo>=0.16.3` - Interaktive Notebooks

### Development Dependencies (nur f√ºr Entwickler)

- `ruff>=0.13.2` - Linting & Formatting
- `ty>=0.0.1a21` - Type checking (Astral)
- `pytest>=8.4.2` - Testing
- `pytest-cov>=7.0.0` - Test Coverage

### Optional Dependencies

- `viz-math`: **plotly**, numpy (üî• EMPFOHLEN f√ºr mathematisch korrekte Graphen)
- `viz-stats`: altair, vega-datasets, pandas (f√ºr statistische Diagramme)
- `viz-static`: matplotlib (f√ºr statische Exporte)
- `docs`: sphinx, sphinx-rtd-theme (f√ºr Dokumentation)
- `types`: Type stubs f√ºr bessere Type Safety

## Quick Start

```python
from schul_analysis.ganzrationale import GanzrationaleFunktion

# Verschiedene Konstruktor-Formate
f1 = GanzrationaleFunktion("x^3-2x+1")     # String (intuitiv)
f2 = GanzrationaleFunktion([1, 0, -2, 1])   # Liste (traditionell)
f3 = GanzrationaleFunktion({3: 1, 1: -2, 0: 1})  # Dictionary

# Berechnungen
nullstellen = f1.nullstellen()           # [1.0, 2.0]
ableitung = f1.ableitung()               # GanzrationaleFunktion
extremstellen = f1.extremstellen()       # [(1.5, "Minimum")]

# L√∂sungsweg als Markdown
weg = f1.nullstellen_weg()
print(weg)  # Detaillierter Schritt-f√ºr-Schritt-L√∂sungsweg
```

## In Marimo Notebooks

```python
import marimo as mo
from schul_analysis.ganzrationale import GanzrationaleFunktion

# Mathematisch korrekte Visualisierung mit Plotly (EMPFOHLEN)
f = GanzrationaleFunktion("x^2-4x+3")

# LaTeX-Darstellung in Marimo
mo.md(f"## Funktion: $$f(x) = {f.term_latex()}$$")

# üî• Perfekte Parabel-Darstellung mit Plotly
mo.ui.plotly(f.perfekte_parabel_plotly())

# Interaktiver L√∂sungsweg
f.zeige_nullstellen_marimo(real=True)

# Alternative: Statistische Visualisierung mit Altair
f.zeige_funktion_altair()
```

### Visualisierungs-Pakete w√§hlen

**üî• F√ºr Mathematik (EMPFOHLEN):**

```bash
uv sync --group viz-math  # Installiert Plotly f√ºr perfekte mathematische Darstellung
```

**üìä F√ºr Statistik:**

```bash
uv sync --group viz-stats  # Installiert Altair f√ºr statistische Diagramme
```

**üñºÔ∏è F√ºr statische Exporte:**

```bash
uv sync --group viz-static  # Installiert Matplotlib f√ºr PDF/PNG Export
```

## Entwicklung

### Setup f√ºr Entwicklung

```bash
# Repository klonen
git clone https://github.com/kuelshammer/schul-analysis.git
cd schul-analysis

# Entwicklungsumgebung einrichten
uv sync --all-groups
```

### Code Quality

```bash
# Type checking mit ty
uv run ty check

# Linting mit ruff
uv run ruff check
uv run ruff format

# Tests ausf√ºhren
uv run pytest

# Tests mit Coverage
uv run pytest --cov=schul_analysis
```

### Projektstruktur

```
schul-analysis/
‚îú‚îÄ‚îÄ src/schul_analysis/          # Source code
‚îÇ   ‚îú‚îÄ‚îÄ basis/                   # Base classes
‚îÇ   ‚îú‚îÄ‚îÄ ganzrationale/           # Polynomial functions
‚îÇ   ‚îú‚îÄ‚îÄ exponential/             # Exponential functions
‚îÇ   ‚îî‚îÄ‚îÄ trigonometrisch/         # Trigonometric functions
‚îú‚îÄ‚îÄ tests/                       # Test files
‚îú‚îÄ‚îÄ docs/                        # Documentation
‚îú‚îÄ‚îÄ notebooks/                   # Marimo notebooks
‚îî‚îÄ‚îÄ pyproject.toml              # Project configuration
```

## Lizenz

MIT License - siehe [LICENSE](LICENSE) f√ºr Details.

## Contributing

1. Fork das Repository
2. Erstelle einen Feature Branch (`git checkout -b feature/amazing-feature`)
3. Commit deine √Ñnderungen (`git commit -m 'Add amazing feature'`)
4. Push zum Branch (`git push origin feature/amazing-feature`)
5. Erstelle einen Pull Request

## Unterst√ºtzung

Bei Fragen oder Problemen erstelle bitte ein [Issue](https://github.com/kuelshammer/schul-analysis/issues).
